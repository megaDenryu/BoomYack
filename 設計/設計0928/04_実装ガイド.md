# 04_実装ガイド

## 配置物集約の完全実装例

### 付箋集約の実装

```typescript
import { 配置物ID } from "../../ID";
import { I付箋集約, I付箋View, I付箋VM } from "../I配置物";
import { 付箋View } from "./付箋View";
import { 付箋VM } from "./付箋VM";
import { 配置物ドラッグコントローラー } from "../ドラッグシステム/配置物ドラッグコントローラー";
import { VM座標 } from "../../位置関係";

export class 付箋集約 implements I付箋集約 {
    public readonly view: I付箋View;
    public readonly vm: I付箋VM;
    private dragController: 配置物ドラッグコントローラー;

    constructor(
        initialPosition: VM座標,
        id: 配置物ID,
        canvasAggregate: I描画キャンバス集約
    ) {
        // VM作成
        this.vm = new 付箋VM(id, initialPosition);
        
        // View作成
        this.view = new 付箋View();
        
        // 相互バインド
        this.bindViewAndVM();
        
        // ドラッグ機能設定
        this.dragController = new 配置物ドラッグコントローラー(
            id,
            this.view,
            canvasAggregate
        );
    }

    private bindViewAndVM(): void {
        // ViewにVMを注入（プッシュ型通知開始）
        this.view.bindVM(this.vm);
        
        // ViewからVMへの操作を設定
        this.view.onContentEdit((newContent: string) => {
            this.vm.updateContent(newContent);
        });
        
        this.view.onSizeChange((newSize: サイズ) => {
            this.vm.updateSize(newSize);
        });
    }

    public updatePosition(newPosition: VM座標): void {
        this.vm.updatePosition(newPosition);
    }

    public setSelected(selected: boolean): void {
        this.vm.setSelected(selected);
    }

    public dispose(): void {
        // リソース解放
        this.view.unbindVM();
        this.dragController.dispose();
    }
}
```

### 付箋VM完全実装

```typescript
export interface I付箋VMState extends I配置物VMState {
    content: string;
    backgroundColor: string;
    fontSize: number;
}

export class 付箋VM extends ObservableVM<I付箋VMState> implements I付箋VM {
    public readonly 配置物ID: 配置物ID;
    public readonly 配置物種別 = '付箋' as const;

    constructor(id: 配置物ID, initialPosition: VM座標) {
        const initialState: I付箋VMState = {
            position: initialPosition,
            size: new サイズ(new Px長さ(200), new Px長さ(150)),
            selected: false,
            visible: true,
            content: '',
            backgroundColor: '#ffeb3b',
            fontSize: 14
        };
        
        super(initialState);
        this.配置物ID = id;
    }

    public updateContent(content: string): void {
        this.setState({
            ...this.state,
            content
        });
    }

    public updateBackgroundColor(color: string): void {
        this.setState({
            ...this.state,
            backgroundColor: color
        });
    }

    public updateFontSize(fontSize: number): void {
        this.setState({
            ...this.state,
            fontSize
        });
    }

    // 永続化用のシリアライゼーション
    public toJSON(): any {
        return {
            id: this.配置物ID.toString(),
            type: this.配置物種別,
            state: this.state
        };
    }

    public static fromJSON(data: any): 付箋VM {
        const vm = new 付箋VM(
            new 配置物ID(data.id),
            new VM座標(data.state.position.x, data.state.position.y)
        );
        
        vm.setState({
            ...data.state,
            position: new VM座標(data.state.position.x, data.state.position.y),
            size: new サイズ(
                new Px長さ(data.state.size.幅.value),
                new Px長さ(data.state.size.高さ.value)
            )
        });
        
        return vm;
    }
}
```

### 付箋View完全実装

```typescript
export class 付箋View extends 配置物ViewBase implements I付箋View {
    private contentEditor: HTMLDivElement;
    private resizeHandle: HTMLDivElement;
    private vmStateListener: IStateChangeListener<I付箋VMState>;
    private vm: I付箋VM;
    
    // イベントコールバック
    private onContentEditCallback: (content: string) => void;
    private onSizeChangeCallback: (size: サイズ) => void;

    constructor() {
        super();
        this.setupStateListener();
        this.createUI();
        this.setupEventListeners();
    }

    protected createComponentRoot(): DivC {
        return new DivC({})
            .setStyleCSS({
                position: 'absolute',
                width: '200px',
                height: '150px',
                backgroundColor: '#ffeb3b',
                border: '1px solid #ddd',
                borderRadius: '4px',
                cursor: 'grab',
                userSelect: 'none',
                boxShadow: '0 2px 4px rgba(0,0,0,0.1)',
                overflow: 'hidden'
            })
            .addClassName('sticky-note');
    }

    private createUI(): void {
        // コンテンツエディター
        this.contentEditor = document.createElement('div');
        this.contentEditor.contentEditable = 'true';
        this.contentEditor.style.cssText = `
            width: 100%;
            height: calc(100% - 20px);
            padding: 10px;
            border: none;
            outline: none;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 14px;
            line-height: 1.4;
            background: transparent;
            resize: none;
            overflow-y: auto;
        `;
        
        // リサイズハンドル
        this.resizeHandle = document.createElement('div');
        this.resizeHandle.style.cssText = `
            position: absolute;
            bottom: 2px;
            right: 2px;
            width: 12px;
            height: 12px;
            background: rgba(0,0,0,0.2);
            cursor: se-resize;
            clip-path: polygon(100% 0%, 0% 100%, 100% 100%);
        `;
        
        this._componentRoot.dom.element.appendChild(this.contentEditor);
        this._componentRoot.dom.element.appendChild(this.resizeHandle);
    }

    private setupEventListeners(): void {
        // コンテンツ編集
        this.contentEditor.addEventListener('input', () => {
            if (this.onContentEditCallback) {
                this.onContentEditCallback(this.contentEditor.textContent || '');
            }
        });

        // フォーカス管理
        this.contentEditor.addEventListener('focus', () => {
            this._componentRoot.addClassName('editing');
        });

        this.contentEditor.addEventListener('blur', () => {
            this._componentRoot.removeClassName('editing');
        });

        // リサイズ（簡易実装）
        this.setupResizeHandler();
    }

    private setupResizeHandler(): void {
        let isResizing = false;
        let startSize: { width: number, height: number };
        let startMouse: { x: number, y: number };

        this.resizeHandle.addEventListener('mousedown', (e) => {
            e.stopPropagation(); // ドラッグと競合しないように
            
            isResizing = true;
            const rect = this._componentRoot.dom.element.getBoundingClientRect();
            startSize = { width: rect.width, height: rect.height };
            startMouse = { x: e.clientX, y: e.clientY };
        });

        document.addEventListener('mousemove', (e) => {
            if (!isResizing) return;
            
            const deltaX = e.clientX - startMouse.x;
            const deltaY = e.clientY - startMouse.y;
            
            const newWidth = Math.max(150, startSize.width + deltaX);
            const newHeight = Math.max(100, startSize.height + deltaY);
            
            this._componentRoot.setStyleCSS({
                width: `${newWidth}px`,
                height: `${newHeight}px`
            });
        });

        document.addEventListener('mouseup', () => {
            if (isResizing && this.onSizeChangeCallback) {
                const rect = this._componentRoot.dom.element.getBoundingClientRect();
                const newSize = new サイズ(
                    new Px長さ(rect.width),
                    new Px長さ(rect.height)
                );
                this.onSizeChangeCallback(newSize);
            }
            isResizing = false;
        });
    }

    // MVVMバインディング
    public bindVM(vm: I付箋VM): void {
        if (this.vm) {
            this.vm.unsubscribe(this.vmStateListener);
        }
        
        this.vm = vm;
        this.vm.subscribe(this.vmStateListener);
        this.applyVMState(this.vm.state);
    }

    public unbindVM(): void {
        if (this.vm) {
            this.vm.unsubscribe(this.vmStateListener);
            this.vm = null;
        }
    }

    private setupStateListener(): void {
        this.vmStateListener = {
            onStateChanged: (newState: I付箋VMState, oldState: I付箋VMState) => {
                this.handleVMStateChange(newState, oldState);
            }
        };
    }

    private handleVMStateChange(
        newState: I付箋VMState, 
        oldState: I付箋VMState
    ): void {
        // 位置更新
        if (!newState.position.equals(oldState.position)) {
            // 座標変換は親の描画キャンバス集約が行う
            // ここでは通知を受けるだけ
        }
        
        // コンテンツ更新
        if (newState.content !== oldState.content) {
            if (this.contentEditor.textContent !== newState.content) {
                this.contentEditor.textContent = newState.content;
            }
        }
        
        // 背景色更新
        if (newState.backgroundColor !== oldState.backgroundColor) {
            this._componentRoot.setStyleCSS({
                backgroundColor: newState.backgroundColor
            });
        }
        
        // フォントサイズ更新
        if (newState.fontSize !== oldState.fontSize) {
            this.contentEditor.style.fontSize = `${newState.fontSize}px`;
        }
        
        // サイズ更新
        if (!newState.size.equals(oldState.size)) {
            this._componentRoot.setStyleCSS({
                width: `${newState.size.幅.value}px`,
                height: `${newState.size.高さ.value}px`
            });
        }
        
        // 選択状態更新
        if (newState.selected !== oldState.selected) {
            this.updateSelectionDisplay(newState.selected);
        }
    }

    // コールバック設定
    public onContentEdit(callback: (content: string) => void): void {
        this.onContentEditCallback = callback;
    }

    public onSizeChange(callback: (size: サイズ) => void): void {
        this.onSizeChangeCallback = callback;
    }

    // ドラッグ用メソッド
    public addMouseDownListener(callback: (e: MouseEvent) => void): void {
        this._componentRoot.dom.element.addEventListener('mousedown', (e: MouseEvent) => {
            // エディターエリア内でのクリックはドラッグしない
            if (e.target === this.contentEditor) {
                return;
            }
            callback(e);
        });
    }

    public getBoundingClientRect(): DOMRect {
        return this._componentRoot.dom.element.getBoundingClientRect();
    }
}
```

## CSS定義

```css
/* 付箋共通スタイル */
.sticky-note {
    transition: box-shadow 0.2s ease, transform 0.2s ease;
}

.sticky-note:hover {
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
}

.sticky-note.selected {
    border: 2px solid #2196f3;
    box-shadow: 0 4px 12px rgba(33, 150, 243, 0.3);
}

.sticky-note.dragging {
    box-shadow: 0 8px 25px rgba(0,0,0,0.25);
    transform: rotate(2deg);
    transition: none;
    z-index: 1000;
}

.sticky-note.editing {
    border: 2px solid #4caf50;
    box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
}

/* 編集可能エリア */
.sticky-note [contenteditable] {
    cursor: text;
}

.sticky-note [contenteditable]:focus {
    outline: none;
}

/* リサイズハンドル */
.sticky-note .resize-handle:hover {
    background: rgba(0,0,0,0.4);
}
```

## 使用例

```typescript
// 描画キャンバス集約での配置物作成
export class 描画キャンバス集約 {
    public create付箋(position: VM座標): 付箋集約 {
        const id = new 配置物ID();
        const 付箋 = new 付箋集約(position, id, this);
        
        // 管理対象に追加
        this.items.set(id, 付箋);
        
        // DOMに追加
        this.canvasView.addChild(付箋.view);
        
        return 付箋;
    }
    
    public delete配置物(id: 配置物ID): void {
        const item = this.items.get(id);
        if (item) {
            // DOMから削除
            this.canvasView.removeChild(item.view);
            
            // リソース解放
            item.dispose();
            
            // 管理対象から削除
            this.items.delete(id);
        }
    }
}
```

---
[← 03_状態管理フロー](./03_状態管理フロー.md) | [README に戻る](./README.md)