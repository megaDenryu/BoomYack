# 08_実装ガイド

実際のコード構造（`ノードVM標準描画座標と見なせる`ラップクラス）を活用した、完全な実装ガイドです。

## 全体実装順序

### フェーズ1: 基底システム構築
1. 座標系型定義とユーティリティ
2. Observable観測対象基底クラス
3. 座標変換システム
4. UI基底クラス（LV1/LV2UIComponentBase）

### フェーズ2: VM層実装
1. ノードVM標準描画座標_観測可能
2. ノードVM標準描画座標と見なせる_観測可能
3. 各配置物VM_観測可能（付箋、矢印等）

### フェーズ3: View層実装
1. UI基底クラスの拡張
2. 配置物View_観測対応クラス
3. ドラッグ・選択・編集機能

### フェーズ4: 集約層実装
1. 配置物集約_観測可能クラス
2. 描画キャンバス集約_観測統合
3. 統合テスト

## 詳細実装例

### 1. 基底Observable観測対象システム

```typescript
// ========== Observer基底インターフェース ==========
export interface Observer観測者 {
    変更受信(変更元: Observable観測対象, 変更データ: 変更通知データ): void;
}

export interface 変更通知データ {
    変更種別: VM変更種別;
    変更ID: string;
    旧値: any;
    新値: any;
    タイムスタンプ: number;
    変更元情報: {
        クラス名: string;
        インスタンスID: string;
    };
    追加情報?: Record<string, any>;
}

export enum VM変更種別 {
    位置変更 = 'POSITION_CHANGE',
    サイズ変更 = 'SIZE_CHANGE',
    可視性変更 = 'VISIBILITY_CHANGE',
    タイトル変更 = 'TITLE_CHANGE',
    内容変更 = 'CONTENT_CHANGE',
    背景色変更 = 'BACKGROUND_COLOR_CHANGE',
    フォントサイズ変更 = 'FONT_SIZE_CHANGE',
    ドラッグ状態変更 = 'DRAG_STATE_CHANGE',
    選択状態変更 = 'SELECTION_STATE_CHANGE',
    削除 = 'DELETE'
}

// ========== Observable基底クラス ==========
export abstract class Observable観測対象 {
    private static インスタンス通番: number = 0;
    protected readonly インスタンスID: string;
    private 観測者リスト: Set<Observer観測者> = new Set();
    private 通知中フラグ: boolean = false;
    private 通知待機キュー: 変更通知データ[] = [];

    constructor() {
        this.インスタンスID = `${this.constructor.name}_${++Observable観測対象.インスタンス通番}`;
    }

    public 観測者登録(観測者: Observer観測者): void {
        this.観測者リスト.add(観測者);
    }

    public 観測者削除(観測者: Observer観測者): void {
        this.観測者リスト.delete(観測者);
    }

    protected 変更通知(変更種別: VM変更種別, 旧値: any, 新値: any, 追加情報?: Record<string, any>): void {
        const 通知データ: 変更通知データ = {
            変更種別,
            変更ID: `${this.インスタンスID}_${Date.now()}_${Math.random()}`,
            旧値,
            新値,
            タイムスタンプ: Date.now(),
            変更元情報: {
                クラス名: this.constructor.name,
                インスタンスID: this.インスタンスID
            },
            追加情報
        };

        if (this.通知中フラグ) {
            // 通知中の場合はキューに追加（無限ループ防止）
            this.通知待機キュー.push(通知データ);
            return;
        }

        this.通知実行(通知データ);
    }

    private 通知実行(通知データ: 変更通知データ): void {
        this.通知中フラグ = true;
        
        try {
            // 非同期通知でUI更新の無限ループを防止
            requestAnimationFrame(() => {
                const 通知対象観測者リスト = Array.from(this.観測者リスト);
                
                for (const 観測者 of 通知対象観測者リスト) {
                    try {
                        観測者.変更受信(this, 通知データ);
                    } catch (error) {
                        console.error(`観測者 ${観測者.constructor.name} への通知でエラー:`, error);
                        this.観測者削除(観測者);
                    }
                }
                
                this.通知中フラグ = false;
                this.待機キュー処理();
            });
        } catch (error) {
            this.通知中フラグ = false;
            console.error('通知実行エラー:', error);
        }
    }

    private 待機キュー処理(): void {
        while (this.通知待機キュー.length > 0 && !this.通知中フラグ) {
            const 待機通知 = this.通知待機キュー.shift()!;
            this.通知実行(待機通知);
        }
    }
}
```

### 2. 座標系統合型定義

```typescript
// ========== 基底座標型 ==========
export abstract class 座標点基底 {
    abstract get x(): Px長さ;
    abstract get y(): Px長さ;
    abstract 複製(): this;
    abstract 等価判定(他の座標: this): boolean;
    
    public 距離計算(他の座標: this): number {
        const dx = this.x.値 - 他の座標.x.値;
        const dy = this.y.値 - 他の座標.y.値;
        return Math.sqrt(dx * dx + dy * dy);
    }
    
    public 角度計算(他の座標: this): number {
        const dx = 他の座標.x.値 - this.x.値;
        const dy = 他の座標.y.値 - this.y.値;
        return Math.atan2(dy, dx);
    }
}

// ========== 各座標系実装 ==========
export class 描画座標点 extends 座標点基底 {
    constructor(
        private _x: Px長さ,
        private _y: Px長さ
    ) {
        super();
    }

    public get x(): Px長さ { return this._x; }
    public get y(): Px長さ { return this._y; }

    public 加算(他の点: 描画座標点): 描画座標点 {
        return new 描画座標点(
            new Px長さ(this.x.値 + 他の点.x.値),
            new Px長さ(this.y.値 + 他の点.y.値)
        );
    }

    public 減算(他の点: 描画座標点): 描画座標点 {
        return new 描画座標点(
            new Px長さ(this.x.値 - 他の点.x.値),
            new Px長さ(this.y.値 - 他の点.y.値)
        );
    }

    public スケール(倍率: number): 描画座標点 {
        return new 描画座標点(
            new Px長さ(this.x.値 * 倍率),
            new Px長さ(this.y.値 * 倍率)
        );
    }

    public 複製(): 描画座標点 {
        return new 描画座標点(this.x, this.y);
    }

    public 等価判定(他の点: 描画座標点): boolean {
        const 許容誤差 = 0.01;
        return Math.abs(this.x.値 - 他の点.x.値) < 許容誤差 &&
               Math.abs(this.y.値 - 他の点.y.値) < 許容誤差;
    }

    public toString(): string {
        return `描画座標(${this.x.値}, ${this.y.値})`;
    }
}

export class 画面座標点 extends 座標点基底 {
    constructor(
        private _x: Px長さ,
        private _y: Px長さ
    ) {
        super();
    }

    public get x(): Px長さ { return this._x; }
    public get y(): Px長さ { return this._y; }

    public ブラウザ座標取得(): {x: number, y: number} {
        return { x: this.x.値, y: this.y.値 };
    }

    public 相対位置計算(基準要素: HTMLElement): 画面座標点 {
        const 要素境界 = 基準要素.getBoundingClientRect();
        return new 画面座標点(
            new Px長さ(this.x.値 - 要素境界.left),
            new Px長さ(this.y.値 - 要素境界.top)
        );
    }

    public 複製(): 画面座標点 {
        return new 画面座標点(this.x, this.y);
    }

    public 等価判定(他の点: 画面座標点): boolean {
        const 許容誤差 = 0.01;
        return Math.abs(this.x.値 - 他の点.x.値) < 許容誤差 &&
               Math.abs(this.y.値 - 他の点.y.値) < 許容誤差;
    }
}

export class 図形内座標点 extends 座標点基底 {
    constructor(
        private _x: Px長さ,
        private _y: Px長さ
    ) {
        super();
    }

    public get x(): Px長さ { return this._x; }
    public get y(): Px長さ { return this._y; }

    public 正規化(図形サイズ: サイズ): 正規化座標点 {
        return new 正規化座標点(
            this.x.値 / 図形サイズ.width.値,
            this.y.値 / 図形サイズ.height.値
        );
    }

    public 図形境界判定(図形サイズ: サイズ): boolean {
        return this.x.値 >= 0 && this.x.値 <= 図形サイズ.width.値 &&
               this.y.値 >= 0 && this.y.値 <= 図形サイズ.height.値;
    }

    public コーナー判定(図形サイズ: サイズ, コーナーサイズ: number): コーナー種別 {
        const 右端 = 図形サイズ.width.値;
        const 下端 = 図形サイズ.height.値;
        
        if (this.x.値 <= コーナーサイズ && this.y.値 <= コーナーサイズ) {
            return コーナー種別.左上;
        } else if (this.x.値 >= 右端 - コーナーサイズ && this.y.値 <= コーナーサイズ) {
            return コーナー種別.右上;
        } else if (this.x.値 <= コーナーサイズ && this.y.値 >= 下端 - コーナーサイズ) {
            return コーナー種別.左下;
        } else if (this.x.値 >= 右端 - コーナーサイズ && this.y.値 >= 下端 - コーナーサイズ) {
            return コーナー種別.右下;
        }
        
        return コーナー種別.なし;
    }

    public 複製(): 図形内座標点 {
        return new 図形内座標点(this.x, this.y);
    }

    public 等価判定(他の点: 図形内座標点): boolean {
        const 許容誤差 = 0.01;
        return Math.abs(this.x.値 - 他の点.x.値) < 許容誤差 &&
               Math.abs(this.y.値 - 他の点.y.値) < 許容誤差;
    }
}

export enum コーナー種別 {
    なし = 'NONE',
    左上 = 'TOP_LEFT',
    右上 = 'TOP_RIGHT',
    左下 = 'BOTTOM_LEFT',
    右下 = 'BOTTOM_RIGHT'
}
```

### 3. ノードVM標準描画座標_観測可能実装

```typescript
export class ノードVM標準描画座標_観測可能 extends Observable観測対象 {
    private _位置: 描画座標点;
    private _サイズ: サイズ;
    private _可視性: boolean = true;
    private _zIndex: number = 0;
    private _回転角度: number = 0;
    private _透明度: number = 1.0;

    constructor(
        初期位置: 描画座標点, 
        初期サイズ: サイズ,
        初期設定?: Partial<ノードVM初期設定>
    ) {
        super();
        this._位置 = 初期位置.複製();
        this._サイズ = 初期サイズ;
        
        if (初期設定) {
            this._可視性 = 初期設定.可視性 ?? true;
            this._zIndex = 初期設定.zIndex ?? 0;
            this._回転角度 = 初期設定.回転角度 ?? 0;
            this._透明度 = 初期設定.透明度 ?? 1.0;
        }
    }

    // ========== 位置プロパティ ==========
    public get 位置(): 描画座標点{
        return this._位置.複製();
    }

    public set 位置(新しい位置: 描画座標点) {
        if (this._位置.等価判定(新しい位置)) return;
        
        const 旧位置 = this._位置.複製();
        this._位置 = 新しい位置.複製();
        
        this.変更通知(VM変更種別.位置変更, 旧位置, this._位置, {
            移動距離: 旧位置.距離計算(this._位置),
            移動角度: 旧位置.角度計算(this._位置)
        });
    }

    // ========== サイズプロパティ ==========
    public get サイズ(): サイズ {
        return this._サイズ;
    }

    public set サイズ(新しいサイズ: サイズ) {
        if (this._サイズ.等価判定(新しいサイズ)) return;
        
        const 旧サイズ = this._サイズ;
        this._サイズ = 新しいサイズ;
        
        this.変更通知(VM変更種別.サイズ変更, 旧サイズ, 新しいサイズ, {
            幅変更量: 新しいサイズ.width.値 - 旧サイズ.width.値,
            高さ変更量: 新しいサイズ.height.値 - 旧サイズ.height.値
        });
    }

    // ========== 可視性プロパティ ==========
    public get 可視性(): boolean {
        return this._可視性;
    }

    public set 可視性(可視: boolean) {
        if (this._可視性 === 可視) return;
        
        const 旧可視性 = this._可視性;
        this._可視性 = 可視;
        
        this.変更通知(VM変更種別.可視性変更, 旧可視性, 可視);
    }

    // ========== zIndexプロパティ ==========
    public get zIndex(): number {
        return this._zIndex;
    }

    public set zIndex(新しいzIndex: number) {
        if (this._zIndex === 新しいzIndex) return;
        
        const 旧zIndex = this._zIndex;
        this._zIndex = 新しいzIndex;
        
        this.変更通知('Z_INDEX_CHANGE' as VM変更種別, 旧zIndex, 新しいzIndex);
    }

    // ========== 高度な操作メソッド ==========
    public 位置移動(移動量: 描画座標点): void {
        const 新しい位置 = this._位置.加算(移動量);
        this.位置 = 新しい位置;
    }

    public サイズ変更(変更量: {幅: Px長さ, 高さ: Px長さ}): void {
        const 新しいサイズ = new サイズ(
            new Px長さ(this._サイズ.width.値 + 変更量.幅.値),
            new Px長さ(this._サイズ.height.値 + 変更量.高さ.値)
        );
        this.サイズ = 新しいサイズ;
    }

    public 境界領域取得(): Rectangle {
        return new Rectangle(
            this._位置,
            this._サイズ
        );
    }

    public 中心座標取得(): 描画座標点 {
        return new 描画座標点(
            new Px長さ(this._位置.x.値 + this._サイズ.width.值 / 2),
            new Px長さ(this._位置.y.値 + this._サイズ.height.値 / 2)
        );
    }

    public 座標内判定(座標: 描画座標点): boolean {
        return 座標.x.値 >= this._位置.x.値 &&
               座標.x.値 <= this._位置.x.値 + this._サイズ.width.值 &&
               座標.y.値 >= this._位置.y.値 &&
               座標.y.値 <= this._位置.y.値 + this._サイズ.height.値;
    }
}

// ========== 設定型定義 ==========
export interface ノードVM初期設定 {
    可視性: boolean;
    zIndex: number;
    回転角度: number;
    透明度: number;
}
```

### 4. ノードVM標準描画座標と見なせる_観測可能実装

```typescript
export class ノードVM標準描画座標と見なせる_観測可能<T extends Observable観測対象> 
    extends Observable観測対象 implements Observer観測者 {
    
    private 複合変更通知管理器: 複合変更通知管理器;
    private 変更履歴: 変更履歴管理器;

    constructor(
        private ノードVM標準: ノードVM標準描画座標_観測可能,
        private 実体VM: T
    ) {
        super();
        
        // 初期化
        this.複合変更通知管理器 = new 複合変更通知管理器(this);
        this.変更履歴 = new 変更履歴管理器();
        
        // 両方のVMの変更を監視
        this.ノードVM標準.観測者登録(this);
        this.実体VM.観測者登録(this);
    }

    // ========== アクセサメソッド ==========
    public ノードVM標準(): ノードVM標準描画座標_観測可能 {
        return this.ノードVM標準;
    }

    public 実体<U extends T = T>(): U {
        return this.実体VM as U;
    }

    // ========== 複合操作メソッド ==========
    public 複合状態変更開始(): 複合変更セッション {
        return this.複合変更通知管理器.セッション開始();
    }

    public 複合状態変更通知(変更種別: VM変更種別, 変更データ: any): void {
        this.複合変更通知管理器.変更蓄積(変更種別, 変更データ);
    }

    // ========== Observer観測者実装 ==========
    public 変更受信(変更元: Observable観測対象, 変更データ: 変更通知データ): void {
        // 変更履歴に記録
        this.変更履歴.記録追加(変更データ);
        
        if (変更元 === this.ノードVM標準) {
            this.ノードVM変更受信(変更データ);
        } else if (変更元 === this.実体VM) {
            this.実体VM変更受信(変更データ);
        } else {
            console.warn('未知の変更元からの通知:', 変更元);
        }
    }

    private ノードVM変更受信(変更データ: 変更通知データ): void {
        const 拡張変更データ = {
            ...変更データ,
            変更元種別: 'ノードVM標準' as const,
            ラップクラス情報: {
                ラップクラスID: this.インスタンスID,
                実体VMクラス名: this.実体VM.constructor.name
            }
        };

        this.変更通知(変更データ.変更種別, 変更データ.旧値, 変更データ.新値, 拡張変更データ);
    }

    private 実体VM変更受信(変更データ: 変更通知データ): void {
        const 拡張変更データ = {
            ...変更データ,
            変更元種別: '実体VM' as const,
            ラップクラス情報: {
                ラップクラスID: this.インスタンスID,
                ノードVMクラス名: this.ノードVM標準.constructor.name
            }
        };

        this.変更通知(変更データ.変更種別, 変更データ.旧値, 変更データ.新値, 拡張変更データ);
    }

    // ========== 便利メソッド ==========
    public 位置更新(新しい位置: 描画座標点): void {
        this.ノードVM標準.位置 = 新しい位置;
    }

    public サイズ更新(新しいサイズ: サイズ): void {
        this.ノードVM標準.サイズ = 新しいサイズ;
    }

    public 可視性更新(可視: boolean): void {
        this.ノードVM標準.可視性 = 可視;
    }

    public 現在の境界領域取得(): Rectangle {
        return this.ノードVM標準.境界領域取得();
    }

    public 変更履歴取得(): 変更履歴エントリ[] {
        return this.変更履歴.履歴取得();
    }

    public 変更元別統計取得(): {ノードVM変更数: number, 実体VM変更数: number} {
        return this.変更履歴.変更元別統計();
    }

    // ========== 破棄処理 ==========
    public dispose(): void {
        this.ノードVM標準.観測者削除(this);
        this.実体VM.観測者削除(this);
        this.複合変更通知管理器.dispose();
        this.変更履歴.クリア();
    }
}

// ========== 複合変更管理システム ==========
export class 複合変更通知管理器 {
    private バッチ処理フラグ: boolean = false;
    private 蓄積変更リスト: 変更通知データ[] = [];
    private バッチタイマー: number | null = null;
    private アクティブセッション: Set<複合変更セッション> = new Set();

    constructor(private 親Observable: Observable観測対象) {}

    public セッション開始(): 複合変更セッション {
        const セッション = new 複合変更セッション(this);
        this.アクティブセッション.add(セッション);
        return セッション;
    }

    public セッション終了(セッション: 複合変更セッション): void {
        this.アクティブセッション.delete(セッション);
        if (this.アクティブセッション.size === 0) {
            this.バッチ変更通知実行();
        }
    }

    public 変更蓄積(変更種別: VM変更種別, 変更データ: any): void {
        const 通知データ: 変更通知データ = {
            変更種別,
            変更ID: `batch_${Date.now()}_${Math.random()}`,
            旧値: 変更データ.旧値,
            新値: 変更データ.新値,
            タイムスタンプ: Date.now(),
            変更元情報: {
                クラス名: 'ComplexChangeManager',
                インスタンスID: 'batch'
            },
            追加情報: 変更データ.追加情報
        };

        this.蓄積変更リスト.push(通知データ);
        
        if (this.アクティブセッション.size === 0) {
            // セッションがない場合は自動バッチ処理
            this.自動バッチ処理設定();
        }
    }

    private 自動バッチ処理設定(): void {
        if (this.バッチタイマー !== null) {
            cancelAnimationFrame(this.バッチタイマー);
        }
        
        this.バッチタイマー = requestAnimationFrame(() => {
            this.バッチ変更通知実行();
        });
    }

    private バッチ変更通知実行(): void {
        if (this.蓄積変更リスト.length === 0) return;

        const 処理対象変更リスト = [...this.蓄積変更リスト];
        this.蓄積変更リスト.length = 0;
        this.バッチタイマー = null;

        // 変更種別ごとにグループ化
        const 種別別変更マップ = new Map<VM変更種別, 変更通知データ[]>();
        
        for (const 変更データ of 処理対象変更リスト) {
            const 種別 = 変更データ.変更種別;
            if (!種別別変更マップ.has(種別)) {
                種別別変更マップ.set(種別, []);
            }
            種別別変更マップ.get(種別)!.push(変更データ);
        }

        // 各種別を統合して通知
        for (const [変更種別, 変更リスト] of 種別別変更マップ.entries()) {
            this.統合通知実行(変更種別, 変更リスト);
        }
    }

    private 統合通知実行(変更種別: VM変更種別, 変更リスト: 変更通知データ[]): void {
        if (変更リスト.length === 1) {
            // 単一変更の場合はそのまま通知
            const 変更データ = 変更リスト[0];
            this.親Observable.変更通知(変更種別, 変更データ.旧値, 変更データ.新値, 変更データ.追加情報);
        } else {
            // 複数変更の場合は統合通知
            const 統合追加情報 = {
                バッチフラグ: true,
                変更数: 変更リスト.length,
                個別変更リスト: 変更リスト,
                統合タイムスタンプ: Date.now()
            };
            
            this.親Observable.変更通知(
                変更種別, 
                変更リスト[0].旧値,  // 最初の旧値
                変更リスト[変更リスト.length - 1].新値,  // 最後の新値
                統合追加情報
            );
        }
    }

    public dispose(): void {
        if (this.バッチタイマー !== null) {
            cancelAnimationFrame(this.バッチタイマー);
            this.バッチタイマー = null;
        }
        
        for (const セッション of this.アクティブセッション) {
            セッション.強制終了();
        }
        
        this.蓄積変更リスト.length = 0;
    }
}

// ========== 複合変更セッション ==========
export class 複合変更セッション {
    private 終了フラグ: boolean = false;

    constructor(private 管理器: 複合変更通知管理器) {}

    public 変更追加(変更種別: VM変更種別, 変更データ: any): void {
        if (this.終了フラグ) {
            throw new Error('既に終了したセッションには変更を追加できません');
        }
        
        this.管理器.変更蓄積(変更種別, 変更データ);
    }

    public 終了(): void {
        if (this.終了フラグ) return;
        
        this.終了フラグ = true;
        this.管理器.セッション終了(this);
    }

    public 強制終了(): void {
        this.終了フラグ = true;
    }
}

// ========== 変更履歴管理 ==========
export interface 変更履歴エントリ {
    変更データ: 変更通知データ;
    受信時刻: number;
    変更元種別: 'ノードVM標準' | '実体VM';
}

export class 変更履歴管理器 {
    private 履歴: 変更履歴エントリ[] = [];
    private 最大履歴数: number = 100;

    public 記録追加(変更データ: 変更通知データ): void {
        const エントリ: 変更履歴エントリ = {
            変更データ,
            受信時刻: Date.now(),
            変更元種別: (変更データ.追加情報?.変更元種別 as any) || '不明'
        };

        this.履歴.push(エントリ);
        
        // 履歴数制限
        if (this.履歴.length > this.最大履歴数) {
            this.履歴.shift();
        }
    }

    public 履歴取得(): 変更履歴エントリ[] {
        return [...this.履歴];
    }

    public 変更元別統計(): {ノードVM変更数: number, 実体VM変更数: number} {
        const 統計 = {
            ノードVM変更数: 0,
            実体VM変更数: 0
        };

        for (const エントリ of this.履歴) {
            if (エントリ.変更元種別 === 'ノードVM標準') {
                統計.ノードVM変更数++;
            } else if (エントリ.変更元種別 === '実体VM') {
                統計.実体VM変更数++;
            }
        }

        return 統計;
    }

    public クリア(): void {
        this.履歴.length = 0;
    }
}
```

### 5. 付箋VM_観測可能実装

```typescript
export class 付箋VM_観測可能 extends Observable観測対象 {
    private _配置物ID: 配置物ID;
    private _タイトル: string = '';
    private _内容: string = '';
    private _背景色: string = '#ffeb3b';
    private _フォントサイズ: number = 14;
    private _フォントファミリー: string = 'システムフォント';
    private _テキスト色: string = '#333333';
    private _枠線色: string = '#ffc107';
    private _編集可能フラグ: boolean = true;

    constructor(配置物ID: 配置物ID, 初期設定?: Partial<付箋初期設定>) {
        super();
        this._配置物ID = 配置物ID;
        
        if (初期設定) {
            this._タイトル = 初期設定.タイトル ?? '';
            this._内容 = 初期設定.内容 ?? '';
            this._背景色 = 初期設定.背景色 ?? '#ffeb3b';
            this._フォントサイズ = 初期設定.フォントサイズ ?? 14;
            this._フォントファミリー = 初期設定.フォントファミリー ?? 'システムフォント';
            this._テキスト色 = 初期設定.テキスト色 ?? '#333333';
            this._枠線色 = 初期設定.枠線色 ?? '#ffc107';
            this._編集可能フラグ = 初期設定.編集可能フラグ ?? true;
        }
    }

    // ========== 基本プロパティ ==========
    public get 配置物ID(): 配置物ID {
        return this._配置物ID;
    }

    public get タイトル(): string {
        return this._タイトル;
    }

    public set タイトル(新しいタイトル: string) {
        if (this._タイトル === 新しいタイトル) return;
        
        const 旧タイトル = this._タイトル;
        this._タイトル = 新しいタイトル;
        
        this.変更通知(VM変更種別.タイトル変更, 旧タイトル, 新しいタイトル, {
            文字数変更: 新しいタイトル.length - 旧タイトル.length,
            空文字判定: 新しいタイトル.length === 0
        });
    }

    public get 内容(): string {
        return this._内容;
    }

    public set 内容(新しい内容: string) {
        if (this._内容 === 新しい内容) return;
        
        const 旧内容 = this._内容;
        this._内容 = 新しい内容;
        
        this.変更通知(VM変更種別.内容変更, 旧内容, 新しい内容, {
            文字数変更: 新しい内容.length - 旧内容.length,
            行数変更: 新しい内容.split('\n').length - 旧内容.split('\n').length,
            空文字判定: 新しい内容.length === 0
        });
    }

    // ========== スタイルプロパティ ==========
    public get 背景色(): string {
        return this._背景色;
    }

    public set 背景色(新しい色: string) {
        if (this._背景色 === 新しい色) return;
        
        const 旧色 = this._背景色;
        this._背景色 = 新しい色;
        
        this.変更通知(VM変更種別.背景色変更, 旧色, 新しい色);
    }

    public get フォントサイズ(): number {
        return this._フォントサイズ;
    }

    public set フォントサイズ(新しいサイズ: number) {
        // サイズ範囲制限
        新しいサイズ = Math.max(8, Math.min(72, 新しいサイズ));
        
        if (this._フォントサイズ === 新しいサイズ) return;
        
        const 旧サイズ = this._フォントサイズ;
        this._フォントサイズ = 新しいサイズ;
        
        this.変更通知(VM変更種別.フォントサイズ変更, 旧サイズ, 新しいサイズ, {
            サイズ変更量: 新しいサイズ - 旧サイズ
        });
    }

    public get フォントファミリー(): string {
        return this._フォントファミリー;
    }

    public set フォントファミリー(新しいフォント: string) {
        if (this._フォントファミリー === 新しいフォント) return;
        
        const 旧フォント = this._フォントファミリー;
        this._フォントファミリー = 新しいフォント;
        
        this.変更通知('FONT_FAMILY_CHANGE' as VM変更種別, 旧フォント, 新しいフォント);
    }

    public get テキスト色(): string {
        return this._テキスト色;
    }

    public set テキスト色(新しい色: string) {
        if (this._テキスト色 === 新しい色) return;
        
        const 旧色 = this._テキスト色;
        this._テキスト色 = 新しい色;
        
        this.変更通知('TEXT_COLOR_CHANGE' as VM変更種別, 旧色, 新しい色);
    }

    // ========== 状態プロパティ ==========
    public get 編集可能フラグ(): boolean {
        return this._編集可能フラグ;
    }

    public set 編集可能フラグ(編集可能: boolean) {
        if (this._編集可能フラグ === 編集可能) return;
        
        const 旧フラグ = this._編集可能フラグ;
        this._編集可能フラグ = 編集可能;
        
        this.変更通知('EDITABLE_CHANGE' as VM変更種別, 旧フラグ, 編集可能);
    }

    // ========== 便利メソッド ==========
    public テキスト全体取得(): string {
        if (this._タイトル && this._内容) {
            return `${this._タイトル}\n${this._内容}`;
        } else if (this._タイトル) {
            return this._タイトル;
        } else {
            return this._内容;
        }
    }

    public テキスト全体設定(全テキスト: string): void {
        const 行リスト = 全テキスト.split('\n');
        if (行リスト.length > 1) {
            this.タイトル = 行リスト[0];
            this.内容 = 行リスト.slice(1).join('\n');
        } else {
            this.タイトル = '';
            this.内容 = 全テキスト;
        }
    }

    public 文字数統計取得(): {タイトル文字数: number, 内容文字数: number, 総文字数: number} {
        return {
            タイトル文字数: this._タイトル.length,
            内容文字数: this._内容.length,
            総文字数: this._タイトル.length + this._内容.length
        };
    }

    public スタイル設定一括適用(スタイル設定: Partial<付箋スタイル設定>): void {
        const セッション = new 複合変更セッション(this);
        
        try {
            if (スタイル設定.背景色 !== undefined) {
                this.背景色 = スタイル設定.背景色;
            }
            if (スタイル設定.フォントサイズ !== undefined) {
                this.フォントサイズ = スタイル設定.フォントサイズ;
            }
            if (スタイル設定.フォントファミリー !== undefined) {
                this.フォントファミリー = スタイル設定.フォントファミリー;
            }
            if (スタイル設定.テキスト色 !== undefined) {
                this.テキスト色 = スタイル設定.テキスト色;
            }
            if (スタイル設定.枠線色 !== undefined) {
                this.枠線色 = スタイル設定.枠線色;
            }
        } finally {
            セッション.終了();
        }
    }

    public 現在設定取得(): 付箋現在設定 {
        return {
            配置物ID: this._配置物ID,
            タイトル: this._タイトル,
            内容: this._内容,
            背景色: this._背景色,
            フォントサイズ: this._フォントサイズ,
            フォントファミリー: this._フォントファミリー,
            テキスト色: this._テキスト色,
            枠線色: this._枠線色,
            編集可能フラグ: this._編集可能フラグ
        };
    }
}

// ========== 型定義 ==========
export interface 付箋初期設定 {
    タイトル: string;
    内容: string;
    背景色: string;
    フォントサイズ: number;
    フォントファミリー: string;
    テキスト色: string;
    枠線色: string;
    編集可能フラグ: boolean;
}

export interface 付箋スタイル設定 {
    背景色: string;
    フォントサイズ: number;
    フォントファミリー: string;
    テキスト色: string;
    枠線色: string;
}

export interface 付箋現在設定 extends 付箋初期設定 {
    配置物ID: 配置物ID;
}
```

## 実装チェックリスト

### ✅ 基底システム
- [ ] Observable観測対象基底クラス
- [ ] Observer観測者インターフェース  
- [ ] 変更通知データ型定義
- [ ] VM変更種別enum定義

### ✅ 座標系システム
- [ ] 描画座標点クラス
- [ ] 画面座標点クラス
- [ ] 図形内座標点クラス
- [ ] View座標クラス
- [ ] 座標変換管理器

### ✅ VM層
- [ ] ノードVM標準描画座標_観測可能
- [ ] ノードVM標準描画座標と見なせる_観測可能
- [ ] 付箋VM_観測可能
- [ ] 複合変更通知管理器

### 🔄 View層（次フェーズ）
- [ ] LV1UIComponentBase拡張
- [ ] LV2UIComponentBase拡張
- [ ] 付箋View_観測対応
- [ ] ドラッグ機能

### 🔄 集約層（最終フェーズ）
- [ ] 付箋集約_観測可能
- [ ] 描画キャンバス集約_観測統合
- [ ] 統合テスト

---
[← 07_座標変換システム](./07_座標変換システム.md) | [README →](./README.md)